#!/usr/bin/env bash

set -euo pipefail

ENCRYPTION_VERSION=2

#~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~

usage() {
  cat <<EOF
  Perform variable level encryption or decryption. This tool will process shell scripts or Docker
  env files and encrypt variables matching the following pattern:
  ^(export )?([-A-Za-z0-9_]+=)(.*)

  Commands
    encrypt [--file|-f <file>] [--encryption-passphrase|-e <passphrase>]
    decrypt [--file|-f <file>] [--encryption-passphrase|-e <passphrase>]
      Encrypt or decrypt a single file
    encrypt-all [--directory|-d <directory>] [--encryption-passphrase|-e <passphrase>]
    decrypt-all [--directory|-d <directory>] [--encryption-passphrase|-e <passphrase>]
      Encrypt or decrypt a deployment unit directory. Environment conf and testvars files will be processed.

  Example
    encrypt
      --directory=these/are/my/confs
      --encryption-passphrase=shhthesearesecrets

$1
EOF
exit 1
}

#~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~

main() {
  ARGS=$(getopt -n $(basename ${0}) \
    -l "directory:,encryption-passphrase:,file:,help,debug" \
    -o "d:e:f:h" -- "$@")

  [ $? != 0 ] && usage
  eval set -- "$ARGS"
  while true
  do
    case "$1" in
      --debug) set -x;;
      -d|--directory) DIRECTORY=${2%/};;
      -e|--encryption-passphrase) ENCRYPTION_PASSPHRASE="$2";;
      -f|--file) FILE=$2;;
      -h|--help) usage;;
      --) shift;break;;
    esac
    shift;
  done


  [ $# == 0 ] && usage "No command specified"
  COMMAND=$1
  checkPassphrase
  shift
  case "$COMMAND" in
    e|encrypt) checkFile && encrypt $FILE;;
    d|decrypt) checkFile && decrypt $FILE;;
    ea|encrypt-all) checkDirectory && allFiles encrypt;;
    da|decrypt-all) checkDirectory && allFiles decrypt;;
    *) usage "Unknown command: $COMMAND";;
  esac
}

#~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~

allFiles() {
  local action="${1:-}"

  echo "${action}ing .conf and .testvars files..."
  for file in $(findFiles)
  do
    echo "${action}ing $file"
    $action $file
  done
}

checkFile() {
  if [ -z "${FILE:-}" ]; then usage "Missing variable FILE or option --file|-f."; fi
  if [ ! -f "$FILE" ]; then usage "File not found: $FILE"; fi
}

checkDirectory() {
  if [ -z "${DIRECTORY:-}" ]; then usage "Missing variable DIRECTORY or option --directory|-d."; fi
  if [ ! -d "$DIRECTORY" ]; then usage "Directory not found: $DIRECTORY"; fi
}

checkPassphrase() {
  if [ -z "${ENCRYPTION_PASSPHRASE:-}" ]
  then
    usage "Missing variable ENCRYPTION_PASSPHRASE or option --encryption-passphrase|-e."
  fi
}

findFiles() {
  find $DIRECTORY -maxdepth 1 -name "*.testvars" -o -name "*.conf" -a -not -name "deployment.conf" -a -not -name "test.conf"
}

nativeOrDocker() {
  #
  # The the OpenSSL version that is natively available is safe to use
  # then we will. Otherwise, we'll launch docker with a suitable version.
  #
  if ! openssl version | grep -q "OpenSSL 1.1.1c FIPS"
  then
    echo "docker run -i --rm vasdvp/health-apis-centos:8"
  fi
}

encryption() {
  local returnStatus returnValue
  local version=${1:-}
  local action=${2:-}
  shift
  shift
  local secret="$@"

  # Args specific to the action being performed
  local opensslOpt
  case "${action}" in
    encrypt) opensslOpt="-e";;
    decrypt) opensslOpt="-d";;
    *) logError "Invalid Encryption Type: ${action}"; exit 1;;
  esac

  # Encryption Command
  local doEncryption
  case "${version}" in
    1) doEncryption="openssl enc -aes-256-cbc -md md5 -a -A -nosalt -k ${ENCRYPTION_PASSPHRASE} ${opensslOpt}";;
    2) doEncryption="openssl enc -aes-256-cbc -md md5 -pbkdf2 -iter 1000 -a -A -nosalt -k ${ENCRYPTION_PASSPHRASE} ${opensslOpt}";;
    *) logError "Invalid Encryption Version: ${version}"; exit 1;;
  esac

  local launcher=$(nativeOrDocker)
  returnValue=$(echo -E "${secret}" | ${launcher} ${doEncryption})
  returnStatus=$?

  echo $returnValue
  return $returnStatus
}

encrypt() {
  local file="$1"
  dos2unix -q $file
  sed -i -e '$a\' $file
  local out=$(mktemp)
  grep -qxF '#encrypted' $file && usage "Error: excessive encrypting, egghead" || grep -qxF '#decrypted' $file || echo '#encrypted' >> $out
  while IFS= read -r line
  do
    if [[ "$line" =~ ^(export )?([-A-Za-z0-9_]+=)(.*) ]]
    then
      local secret
      if ! secret=$(encryption ${ENCRYPTION_VERSION} encrypt "${BASH_REMATCH[3]}")
      then
        logError "Encrypt Failed." && exit 1
      fi
      echo -E "${BASH_REMATCH[1]}${BASH_REMATCH[2]}$secret" >> $out
    elif [[ "$line" =~ ^#decrypted ]]
    then
      echo -E '#encrypted' >> $out
    else
      echo -E "$line" >> $out
    fi
  done < "$file"
   cat $out > "$file"
}

decrypt(){
  local file="$1"
  dos2unix -q $file
  local out=$(mktemp)
    grep -qxF '#decrypted' $file && usage "Don't double decrypt, dummy" || grep -qxF '#encrypted' $file || echo '#decrypted' >> $out
  while IFS= read -r line
  do
    if [[ "$line" =~ ^(export )?([-A-Za-z0-9_]+=)(.*) ]]
    then
      local unsecret
      for ((i = ${ENCRYPTION_VERSION}; i >= 1; i--)); do
        if unsecret=$(encryption ${i} decrypt "${BASH_REMATCH[3]}")
        then
          break
        else
          logError "Decrypt v${i} Failed."
          # That's all folks.
          [ "${i}" == "1" ] && logError "Failed to Decrypt." && exit 1
          continue
        fi
      done
      echo -E "${BASH_REMATCH[1]}${BASH_REMATCH[2]}$unsecret" >> $out
    elif [[ "$line" =~ ^#encrypted ]]
    then
      echo -E '#decrypted' >> $out
    else
      echo -E "$line" >> $out
    fi
  done < "$file"
  cat $out > "$file"
  return
}

logError() {
  echo "$@" >&2
}

#~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~

main $@
