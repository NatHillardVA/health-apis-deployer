#!/usr/bin/env bash
set -euo pipefail

export PATH=$(dirname $(readlink -f $0)):$PATH

usage() {
cat >&2 <<EOF
$0 [options] <command>

Track deployment stage

Options

Commands
current [-f <file>]
  Print the current stage
start -s <stage> [-f <file>]
  Complete the current stage if one exists and start a new one.
end -s <stage> [-f <file>]
  Complete the current stage without starting a new one.
  This should only be used at very end of your program.

${1:-}
EOF
exit 1
}

main() {
  local stage= stateFile=${STAGE_STATE_FILE:-.stages}
  local args
  if ! args=$(getopt \
    -l "debug,stage:,state-file:" \
    -o "s:f:" -- "$@")
  then usage; fi
  eval set -- "$args"
  while true
  do
    case "$1" in
      --debug) DEBUG=true;;
      -s|--stage) stage="$2";;
      -f|--state-file) stateFile="$2";;
      --) shift; break;;
    esac
    shift
  done

  if [ -z "${DEBUG:-}" ]; then DEBUG=false; fi
  if [ "$DEBUG" == "true" ]; then set -x; fi

  if [ $# != 1 ]; then usage "Command not specified"; fi
  local command=$1
  case $command in
    current) currentStage "${stateFile}";;
    end) endStage "${stateFile}";;
    start) startStage "${stateFile}" "${stage}" ;;
    *) usage "Unknown command: $command";;
  esac
}

requireParam() {
  local param="${1}"
  local value="${2:-}"
  if [ -z "$value" ]; then usage "Parameter not specified: $param"; fi
}

currentStage() {
  local stateFile="$1"
  if [ -f $stateFile ]; then tail -1 $stateFile; fi
}

endStage() {
  local stateFile="$1"
  current=$(currentStage $stateFile)
  if [ -n "$current" ]; then banner h1 -m "COMPLETED $current"; fi
}

startStage() {
  local stateFile="$1" stage="${2:-}" current=
  requireParam "stage" "$stage"
  endStage "$stateFile"
  stage="${stage^^}"
  echo
  banner h1 -m "STARTING $stage"
  echo $stage >> $stateFile
}


main "$@"
exit 0
