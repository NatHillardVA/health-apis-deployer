# Deployment Unit

+ [Product Repository Structure](#product-repository-structure)
  * [Conf files](#conf-files)
  * [Testvars files](#testvars-files)
  * [Deployment YAML substitution](#deployment-yaml-substitution)
  * [S3 Buckets](#s3-buckets)
  * [Protecting Sensitive Information](#protecting-sensitive-information)
+ [Defining Resource Requests/Limits](#defining-resource-requests-limits)
+ [Blue/Green Deployment Process](#blue-green-deployment-process)
+ [Testing Deployment Units](#testing-deployment-units)
  * [Regression tests](#regression-tests)
  * [Smoke tests](#smoke-tests)
  * [Test container contract](#test-container-contract)

### Product Repository Structure
```
<product>/
├── Jenkinsfile
├── pom.xml
├── deployment.yaml
├── deployment.conf
├── qa.conf
├── qa.testvars
├── staging-lab.conf
├── staging-lab.testvars
├── lab.conf
├── lab.testvars
├── staging.conf
├── staging.testvars
├── production.conf
├── production.testvars
├── test.conf
└┬─ s3/
 ├── */*
 ├── */*.properties
 ├── */*.conf
 ├── */*.yml
 └── */*.yaml
```

`Jenkinsfile`  
Responsible for building DU container and deploying it to Nexus as a project assembly.

`deployment.yaml`  
Contains all k8s resources except ingress objects related to this deployment unit. All items must
be contained with the DU's namespace.

`deployment.conf`
Configuration variables that will be applied in all environments, such as application versions.

`qa.conf`, `staging.conf`, `production.conf`, `staging-lab.conf`, `lab.conf`  
Configuration files for specific environments.

`qa.testvars`, `staging.testvars`, `production.testvars`, `staging-lab.testvars`, `lab.testvars`  
Environment variable files for specific environments used when running tests.  
**WARNING**: Docker env files are literal and do not use shell evaluation. Quotes, dollar signs,
new lines, etc. will be passed literally to your application.

`test.conf`  
Test container configuration for regression and smoke tests. File contents must set `TEST_IMAGE`
to Docker image to run for tests, e.g.
```
export TEST_IMAGE=chillo/armadillo:1.2.3
```

`s3`
This directory will be used to populate a deployment-specific S3 bucket. The contents will processed
using the substitution rules used with conf files. This directory structure can be as deep as
need be. The following file types will be processed for substitution:
- `*.properties`
- `*.conf`
- `*.yaml` or `*.yml`


> ##### Conf files
> `.conf` files are bits of bash code that are evaluated during the deployment process. `.conf`
files may contain bits of logic, functions, etc. to compute values that will be used. However, to
enable substitution in the `deployment.yaml` variables must be exported, e.g.
> ```
> export CHILLO=ARMADILLO`   # $CHILLO is available for substitution
> WIGGLY=PIGGLY              # $WIGGLY is not available
> ```

> ##### Testvars files
> `.testvars` contain variables needed for tests in in Docker `--env-file` format and will be
> used to set environment variables during test execution. Format is `var=value`, one per line, e.g.
> ```
> CHILLO=ARMADILLO
> WIGGLY=PIGGLY
> ```

> ##### Deployment YAML substitution
> The `deployment.yaml` will be processed using `envsubst` to provide environment specific
values to be injected into the yaml. The environment variables from `deployment.conf` and the
environment specific conf, e.g. `qa.conf` will be set. Additional, the following variables will be
also be set.
>  
> `NAMESPACE`  
> The kubernetes namespace the deployment unit must use.
>
> `K8S_ENVIRONMENT`  
> The Kubernetes environment name, e.g. `qa`, `staging`, `production`, `staging-lab` or `lab`
>
> `K8S_DEPLOYMENT_ID`  
> A unique string ID generated by the Jenkins orchestation pipeline for this particular deployment.
>
> `K8S_LOAD_BALANCER`  
> The host name of the load balancer where your deployment will be made available.

>##### S3 Buckets
> Environment-specific S3 buckets will be used to house deployment-specific folders.
> The following environment variables will be provided for substitution in your files.
>
> `DU_AWS_BUCKET_NAME`
> The environment specific bucket name
>
> `DU_S3_FOLDER`
> The deployment specific folder. This folder will be populated with your deployment unit's `s3/`
> folder contents and will be automatically deleted when a deployment is removed from kubernetes.


> ##### Protecting Sensitive Information
> `.conf`  and `.testvars` files may need to contain sensitive information such as access tokens
or passwords. These files should be protected using one of two methods:
> 1. Store as an encrypted zip file
>    Conf files may be stored as an encrypted zip files with `.conf.zip` extension.
>    Likewise, Testvar files may be stored as an encrypted zip files with `.testvars.zip` extension.
> 2. Use the deployer toolkit to encrypt base variables. See [Toolkit usage](toolkit.md) is described below.
>
> Decryption key must be stored in as a Jenkins credential to be used to execute the DU docker image.
Coordinate with the DevOps team if you need encryption.

>This will be changing to property level encryption. For now, to switch to property level encryption for a DU, add a property in the product.conf to be `DU_PROPERTY_LEVEL_ENCRYPTION=true` and encrypt the confs using `ryan-secrets`. Usage is documented in the script.


> ### Defining Resource Requests/Limits
> **IMPORTANT**: Coordinate with the DevOps team to define resource requests/limits. Avoid copy+paste from another product.
>
> Individual pod resource requests/limits for things like CPU and memory will be determined by usage metrics gathered in Prometheus for the deployment. Since usage varies by application, it is necessary to establish how much is needed up-front (requests)for demanding events like app start-up by allowing the app to run limitless in QA, at first. The Devops team will review usage with app owners and work together to establish/negotiate baseline deployment requests/limits.

> Once these are set, the Namespace limits (ResourceQuota) for all deployments of the app will be defined by Devops based on the sum of individual pod limits per deployment in a Namespace and any limit padding necessary to support scaling out additional replicas to meet demand (HorizontalPodAutoscaling).

> Example
>```
> health-apis-exemplar-deployment/deployment.yaml
> ---
> kind: Deployment
> metadata:
>  name: hello
>  namespace: $NAMESPACE
> ...
> resources:
>  requests:
>    memory: "10M"
>    cpu: "1m"
>  limits:
>    memory: "50M"
>    cpu: "10m"
> ```
> ```
> health-apis-deployer/products/exemplar.yaml
> ---
> apiVersion: v1
> kind: ResourceQuota
> metadata:
>   name: exemplar-resource-quota
>   namespace: $DU_NAMESPACE
> spec:
>  hard:
>    limits.cpu: "40m"
>    limits.memory: "200M"

### Blue/Green Deployment Process

The `health-apis-deployment-unit` docker image provides machinery necessary to deploy products into
the k8s cluster. Deployments are orchestrated at a higher level by Jenkins which kick off
deployment, trigger rollback if necessary, and handle reporting.

For a given environment
- Perform sanity check against `deployment.yaml`
- Load `deployment.conf`
- Load `${environment}.conf`
- Perform `envsubst` style substitution on the `deployment.yaml` to produce a final configuration

For each Availability Zone supported by the cluster in this environment
- Detach the deployment unit's green target group from the k8s blue load balancer
- Remove all rules from green load balancer
- Save ingress rules from the DU namespace
- Delete the DU namespace
- Create the namespace
- Restore ingress rules
- Apply substituted final configuration
- Attach deployment unit's green target group to the k8s green load balancer
- Load `test.conf`
- Run regression test container against green load balancer

On regression test success
- Detach the deployment unit's green target group from the k8s green load balancer
- Attach the deployment unit's blue target group to the k8s blue load balancer
- Run smoke test container against blue load balancer
- Begin next AZ

On regression test or smoke test failure in QA
- Environment is left in current state and is available for debugging which may be a mixture of
  partially upgraded AZs
- Gather logs from pods
- Deployment to next AZ is skipped

On regression test or smoke test failure in upper environments
- Logs are captured from all pods in the failed AZ and provided on Jenkins
- Previously installed version is re-applied to this and any previously updated AZs by re-running
  previously installed versions docker image
- Blue load balancer is restored
- Run smoke test container against blue load balancer


Read more about [Blue/Green](blue-green.md)

> The above steps are achieved by a combination of the deployment unit docker image, the routes
docker image, and the Jenkins pipeline that orchestrates the pipeline.

> Regression and smoke test container stdout will be captured and made available on Jenkins.


---
### Testing Deployment Units
The Orchestrating Jenkins pipeline may choose to perform regression or smoke tests based on
various situations.

##### Regression tests
- Ran during product version install
- May be long running

##### Smoke tests
- Ran during route changes to verify connectivity to DU through load balancers and k8s ingress
- Should execute quickly
- Should exercise operations that cover each expect HTTP path  
  For example, if the DU expects paths `/awesome/possum` and `/chillo/armadillo` to be available,
  then a smoke test might simply contain two reads and a health check.

##### Test container contract
- Test container will support test type arguments: `regression-test` and `smoke-test`
- Test container will accept one test type argument at a time: `regression-test` or `smoke-test`
- Test container will be provided the environment variables as listed below
- Test container shall provide an exit code of `0` to indicate success and any non-zero value
  to indicate failure
- Standard out will be captured and provided on Jenkins

The following environment variables will be provided to the test container in both regression and
smoke test modes. (Description above).
- `K8S_ENVIRONMENT`
- `K8S_DEPLOYMENT_ID`
- `K8S_LOAD_BALANCER`

Additionally, any values in `${environment}.testvars` will be passed to your container.

Example
```
docker run \
  --rm \
  --network host \
  --env-file qa.testvars \
  --env K8S_ENVIRONMENT=qa \
  --env K8S_DEPLOYMENT_ID=ABC123 \
  --env K8S_LOAD_BALANCER=green.qa.ligthouse.va.gov \
  vasdvp/health-apis-data-query-test \
  regression-test
```
