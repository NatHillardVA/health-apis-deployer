#!/usr/bin/env bash
. $PLUGIN_LIB

ECS_PARAM_FILE=$DU_DIR/ecs/ecs-params.yml
ECS_DOCKER_COMPOSE_FILE=$DU_DIR/ecs/docker-compose.yml
ALB_PROTOCOL=HTTP

on-activate() {
  echo "TODO SET HTTP PROTOCOL TO HTTPS"
  if [ ! -f $ECS_DOCKER_COMPOSE_FILE ]; then return $PLUGIN_DISABLED; fi
  if [ ! -f $ECS_PARAM_FILE ]; then return $PLUGIN_DISABLED; fi
  return $PLUGIN_ENABLED
}

on-initialize() {
  checkExposedService
  updateDockerCompose
  updateEcsParams
}

on-deploy-green() {
  local tgArn
  tgArn=$(createNewTargetGroup)
  save "new-tg-arn" "$tgArn"
  echo "Target group $tgArn"
  replaceAlbRulesOnGreen $GREEN_LOAD_BALANCER_NAME $GREEN_LOAD_BALANCER_PORT "$tgArn"
  deployService $tgArn
  return 0
}

on-switch-to-blue() {
  local tgArn
  tgArn=$(recall "new-tg-arn")
  addAlbRulesOnBlue $BLUE_LOAD_BALANCER_NAME $BLUE_LOAD_BALANCER_PORT "$tgArn"
  return 0
}

on-after-verify-blue() {
  removeOldTargetGroup
  removeOldServices
  removeOldTaskDefinition
  return 0
}

on-rollback() {
  echo "TODO Delete new target group"
  return 0
}


cluster() {
  echo "lighthouse-${ENVIRONMENT}"
}

deployService() {
  local tgArn=$1
  ecs-cli \
    compose \
    --project-name $(taskDefName) \
    --ecs-params $ECS_PARAM_FILE\
    --file $ECS_DOCKER_COMPOSE_FILE \
    service up \
    --create-log-groups \
    --cluster $(cluster) \
    --launch-type FARGATE \
    --target-groups $(ecsTargetGroupSpecification "$tgArn")
}

ecsTargetGroupSpecification() {
  local tgArn=$1
  local containerPort
  containerPort=$(docker-compose-editor exposed-port \
    --in $ECS_DOCKER_COMPOSE_FILE \
    --service $DU_ECS_EXPOSE_SERVICE)
  echo "targetGroupArn=$tgArn,containerName=$DU_ECS_EXPOSE_SERVICE,containerPort=$containerPort"
}

replaceAlbRulesOnGreen() {
  local alb=$1
  local port=$2
  local tgArn=$3
  echo "Replacing ALB rules on $alb ($port)"
  for priority in ${!DU_LOAD_BALANCER_RULES[@]}
  do
    local path="${DU_LOAD_BALANCER_RULES[$priority]}"
    alb replace-rule \
      --name $alb \
      --protocol $ALB_PROTOCOL \
      --port $port \
      --path "$path" \
      --target-group $tgArn \
      --min-priority $priority
  done
}


addAlbRulesOnBlue() {
  local alb=$1
  local port=$2
  local tgArn=$3
  echo "Adding ALB rules on $alb ($port)"
  for priority in ${!DU_LOAD_BALANCER_RULES[@]}
  do
    local path="${DU_LOAD_BALANCER_RULES[$priority]}"
    alb rule-details \
      --name $alb \
      --protocol $ALB_PROTOCOL \
      --port $port \
      --path "$path" \
      | jq -r '[.RuleArn,.Priority]|join(" ")' \
      | tee -a $WORK/existing.rules
  done
  for priority in ${!DU_LOAD_BALANCER_RULES[@]}
  do
    local path="${DU_LOAD_BALANCER_RULES[$priority]}"
    alb add-rule \
      --name $alb \
      --protocol $ALB_PROTOCOL \
      --port $port \
      --path "$path" \
      --target-group $tgArn \
      --min-priority $priority
  done

  if [ -f $WORK/existing.rules ]
  then
    echo "Deprioritizing old rules"
    local maxPriority
    maxPriority=$(alb rule-summary -n $alb --port $port --protocol $ALB_PROTOCOL \
      | awk 'BEGIN {max=2000} /^[0-9]/ {if ($1 > max) max=$1} END {print max}')
    local priorities
    while read arn priority
    do
      if [ "$priority" -lt 2000 ]
      then
        maxPriority=$(($maxPriority + 1))
        priorities+="RuleArn=$arn,Priority=$maxPriority "
        echo "Moving $arn to slot $maxPriority"
      fi
    done < $WORK/existing.rules
    if [ -n "$priorities" ]
    then
      aws elbv2 set-rule-priorities --rule-priorities "$priorities"
    fi
  fi
}

removeOldRules() {
  if [ -f $WORK/existing.rules ]
  then
    echo "Deleting old rules"
    local offset=2000
    local priorities
    while read arn priority
    do
      aws elbv2 delete-rule --rule-arn $arn
    done < $WORK/existing.rules
  fi
}

removeOldTargetGroup() {
  echo "Deleting old target groups"
  while read arn
  do
    echo "Deleting old target group $arn"
    aws elbv2 delete-target-group --target-group-arn $arn
  done < <(aws elbv2 describe-target-groups \
    --output text \
    --query "TargetGroups[?starts_with(TargetGroupName,'$(awsPrefix)')].[TargetGroupArn]" \
    | grep -v "$(tgName)")
}

removeOldTaskDefinition() {
  echo "Deleting old task definitions"
  aws ecs list-task-definitions \
    --no-paginate \
    --query "taskDefinitionArns[? contains(@,'$(awsPrefix)')]"
  echo ---
  while read arn
  do
    echo "Deleting old task definition $arn"
    aws ecs deregister-task-definition --task-definition $arn --output text
  done < <(aws ecs list-task-definitions \
    --query "taskDefinitionArns[? contains(@,'$(awsPrefix)')]" \
    | jq -r .[] \
    | grep -v "$(taskDefName)")
}

removeOldServices() {
  echo "Deleting old services"
  aws ecs list-services \
    --cluster $(cluster) \
    --query "serviceArns[? contains(@,'$(awsPrefix)')]"
  echo ---
  while read arn
  do
    echo "Deleting old service $arn"
    aws ecs delete-service --cluster $(cluster) --service $arn --force --output text
  done < <(aws ecs list-services \
    --cluster $(cluster) \
    --query "serviceArns[? contains(@,'$(awsPrefix)')]" \
    | jq -r .[] \
    | grep -v "$(taskDefName)")
}

awsPrefix() {
  echo "ecs-${PRODUCT}-${SHORT_ENVIRONMENT}-"
}

tgName() {
  echo "$(awsPrefix)${BUILD_NUMBER}-tg"
}

taskDefName() {
  echo "$(awsPrefix)${BUILD_NUMBER}"
}

createNewTargetGroup() {
  local targetGroupName= containerPort= tgArn=
  targetGroupName=$(tgName)
  containerPort=$(docker-compose-editor exposed-port \
    --in $ECS_DOCKER_COMPOSE_FILE \
    --service $DU_ECS_EXPOSE_SERVICE)
  aws elbv2 create-target-group \
    --vpc-id $(vpc id-for-environment -e $VPC) \
    --name $targetGroupName \
    --port $containerPort \
    --target-type ip \
    --protocol HTTP \
    --health-check-protocol HTTP \
    --health-check-port traffic-port \
    --health-check-enabled \
    --health-check-interval-seconds 30 \
    --health-check-timeout-seconds 5 \
    --healthy-threshold-count 3 \
    --unhealthy-threshold-count 3 \
    --health-check-path "$DU_HEALTH_CHECK_PATH" \
    --matcher HttpCode=200 \
    > $WORK/$targetGroupName
  tgArn=$(jq -r '.TargetGroups[].TargetGroupArn' $WORK/$targetGroupName)
  echo $tgArn
}

checkExposedService() {
  if [ -z "${DU_ECS_EXPOSE_SERVICE:-}" ]
  then
    abort "DU_ECS_EXPOSE_SERVICE is not defined in product conf"
  fi
  local port=
  port=$(docker-compose-editor exposed-port -i $ECS_DOCKER_COMPOSE_FILE -s $DU_ECS_EXPOSE_SERVICE)
  if [ -z "$port" ]
  then
    abort "Service $ECS_DOCKER_COMPOSE_FILE does not appear to be mapped to a port"
  fi
}

updateEcsParams() {
  local subnets securityGroups
  subnets=$(vpc subnets -e $VPC)
  local securityGroupName="ecs-task-${ENVIRONMENT}-sg"
  securityGroups=$(vpc security-groups -g $securityGroupName -e $VPC)

  echo "Using subnets $subnets"
  echo "Using security group $securityGroupName ($securityGroups)"
  if [ -z "$subnets" ]; then abort "Subnets not found for $VPC"; fi
  if [ -z "$securityGroups" ]; then abort "Security groups not found for $securityGroupName"; fi

  substitute-env rewrite -e $PLUGIN_SUBSTITION_DIR -f $ECS_PARAM_FILE
  ecs-params-editor rewrite \
    -i $ECS_PARAM_FILE \
    -o $ECS_PARAM_FILE \
    --replace-subnets "$subnets" \
    --replace-security-groups "$securityGroups" \
    --replace-task-execution-role "$ECS_TASK_EXECUTION_ROLE"

  banner file -m $ECS_PARAM_FILE
  cat $ECS_PARAM_FILE
}

updateDockerCompose() {
  substitute-env rewrite -e $PLUGIN_SUBSTITION_DIR -f $ECS_DOCKER_COMPOSE_FILE
  local image= org= name= version=
  for service in $(docker-compose-editor services -i $ECS_DOCKER_COMPOSE_FILE)
  do
    echo "Updating $service definition"
    image=$(docker-compose-editor image -i $ECS_DOCKER_COMPOSE_FILE -s $service)
    if [[ ! "$image" =~ ([^/]*)/([^:]*):(.*) ]]; then abort "Do not understand image: $image"; fi
    org="${BASH_REMATCH[1]}"
    name="${BASH_REMATCH[2]}"
    tag="${BASH_REMATCH[3]}"
    if [[ $org != *dkr.ecr.*.amazonaws.com* ]]
    then
      local ecrImage
      ecrImage="$(ecr hostname -n $name)/$name:$tag"
      importToEcr "$image" "$ecrImage"
      docker-compose-editor rewrite \
        -i $ECS_DOCKER_COMPOSE_FILE \
        -o $ECS_DOCKER_COMPOSE_FILE \
        --replace-image "$service:$ecrImage"
    fi
  done
  banner file -m $ECS_DOCKER_COMPOSE_FILE
  cat $ECS_DOCKER_COMPOSE_FILE
}

importToEcr() {
  local image="$1"
  local ecrImage="$2"
  ecr login -n $name
  if DOCKER_CLI_EXPERIMENTAL=enabled docker manifest inspect $ecrImage > /dev/null
  then
    echo "Image $image already exists as $ecrImage"
    return
  fi
  echo "Importing $image to $ecrImage"
  docker pull -q $image
  docker tag $image $ecrImage
  docker push $ecrImage
  docker rmi $image $ecrImage
}


main "$@"
exit 1
