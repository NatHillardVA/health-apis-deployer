#!/usr/bin/env bash
. $PLUGIN_LIB

ECS_PARAM_FILE=$DU_DIR/ecs/ecs-params.yml
ECS_DOCKER_COMPOSE_FILE=$DU_DIR/ecs/docker-compose.yml

on-activate() {
  if [ ! -f $ECS_DOCKER_COMPOSE_FILE ]; then return $PLUGIN_DISABLED; fi
  if [ ! -f $ECS_PARAM_FILE ]; then return $PLUGIN_DISABLED; fi
  return $PLUGIN_ENABLED
}

on-initialize() {
  updateDockerCompose
  updateEcsParams
}


updateEcsParams() {
  local subnets securityGroups
  subnets=$(vpc subnets -e $VPC)
  #
  # Security groups will need to be created per VPC to allow
  # traffic to the ports. I think we should designate a port
  # range 443, 80, 8000-9000?
  # Otherwise, we'll have to parse the YML and determine what
  # security group should be and create/destroy it.
  #
  securityGroups=$(vpc security-groups -g $ECS_SECURITY_GROUP_NAME -e $VPC)
  
  echo "Using subnets $subnets"
  echo "Using security group $ECS_SECURITY_GROUP_NAME ($securityGroups)"
  if [ -z "$subnets" ]; then abort "Subnets not found for $VPC"; fi
  if [ -z "$securityGroups" ]; then abort "Security groups not found for $ECS_SECURITY_GROUP_NAME"; fi

  substitute-env rewrite -e $PLUGIN_SUBSTITION_DIR -f $ECS_PARAM_FILE
  banner file -m $ECS_PARAM_FILE

  ecs-params-editor rewrite \
    -i $ECS_PARAM_FILE \
    -o $ECS_PARAM_FILE \
    --replace-subnets "$subnets" \
    --replace-security-groups "$securityGroups"

    cat $ECS_PARAM_FILE
echo "UPDATE NETWORK CONFIGURATION"
}

updateDockerCompose() {
  substitute-env rewrite -e $PLUGIN_SUBSTITION_DIR -f $ECS_DOCKER_COMPOSE_FILE
  local image= org= name= version=
  for service in $(docker-compose-editor services -i $ECS_DOCKER_COMPOSE_FILE)
  do
    echo "Updating $service definition"
    image=$(docker-compose-editor image -i $ECS_DOCKER_COMPOSE_FILE -s $service)
    if [[ ! "$image" =~ ([^/]*)/([^:]*):(.*) ]]; then abort "Do not understand image: $image"; fi
    org="${BASH_REMATCH[1]}"
    name="${BASH_REMATCH[2]}"
    tag="${BASH_REMATCH[3]}"
    if [[ $org != *dkr.ecr.*.amazonaws.com* ]]
    then
      local ecrImage
      ecrImage="$(ecr hostname -n $name)/$name:$tag"
      importToEcr "$image" "$ecrImage"
      docker-compose-editor rewrite \
        -i $ECS_DOCKER_COMPOSE_FILE \
        -o $ECS_DOCKER_COMPOSE_FILE \
        --replace-image "$service:$ecrImage"
    fi
  done
  banner file -m $ECS_DOCKER_COMPOSE_FILE
  cat $ECS_DOCKER_COMPOSE_FILE
}

importToEcr() {
  local image="$1"
  local ecrImage="$2"
  ecr login -n $name
  if DOCKER_CLI_EXPERIMENTAL=enabled docker manifest inspect $ecrImage > /dev/null
  then
    echo "Image $image already exists as $ecrImage"
    return
  fi
  echo "Importing $image to $ecrImage"
  docker pull -q $image
  docker tag $image $ecrImage
  docker push $ecrImage
  docker rmi $image $ecrImage
}


main "$@"
exit 1
